package site.addzero.jimmer.apt.processor.analyzer

import site.addzero.jimmer.apt.processor.model.*
import site.addzero.util.lsi.field.LsiField
import site.addzero.util.lsi.anno.LsiAnnotation

/**
 * Jimmer字段分析器
 * 
 * 专门负责分析Jimmer实体字段的各种注解和属性
 */
class JimmerFieldAnalyzer {

    private val annotationExtractor = JimmerAnnotationExtractor()

    /**
     * 分析字段并创建字段元数据
     */
    fun analyzeField(lsiField: LsiField): FieldMetadata {
        val jimmerFieldInfo = annotationExtractor.extractFieldInfo(lsiField)
        
        return FieldMetadata(
            lsiField = lsiField,
            columnName = determineColumnName(lsiField, jimmerFieldInfo),
            isPrimaryKey = isPrimaryKey(lsiField),
            isAutoGenerated = isAutoGenerated(lsiField),
            isBusinessKey = jimmerFieldInfo.key,
            isFormula = jimmerFieldInfo.formula != null,
            isIdView = jimmerFieldInfo.idView != null,
            isVersion = jimmerFieldInfo.version,
            columnType = determineColumnType(lsiField),
            nullable = isNullable(lsiField),
            length = extractLength(lsiField),
            precision = extractPrecision(lsiField),
            scale = extractScale(lsiField),
            jimmerFieldInfo = jimmerFieldInfo
        )
    }

    /**
     * 判断字段是否应该包含在DDL生成中
     */
    fun shouldIncludeInDDL(lsiField: LsiField): Boolean {
        // 排除计算属性
        if (annotationExtractor.isComputedProperty(lsiField)) {
            return false
        }
        
        // 排除静态字段
        if (lsiField.isStatic) {
            return false
        }
        
        // 排除集合类型字段（关系字段）
        if (lsiField.type?.isCollectionType == true) {
            return false
        }
        
        // 排除关系字段（除了ManyToOne，它需要外键列）
        val relationshipType = determineRelationshipType(lsiField)
        if (relationshipType != null && relationshipType != RelationshipType.MANY_TO_ONE) {
            return false
        }
        
        return true
    }

    // ========== 私有辅助方法 ==========

    private fun determineColumnName(lsiField: LsiField, jimmerFieldInfo: JimmerFieldInfo): String {
        // 优先使用@Column注解中指定的名称
        jimmerFieldInfo.columnName?.let { return it }
        
        // 使用字段名转换为下划线命名
        return lsiField.name?.let { camelToSnakeCase(it) } ?: "unknown_column"
    }

    private fun isPrimaryKey(lsiField: LsiField): Boolean {
        return lsiField.annotations.any { annotation ->
            annotation.qualifiedName == "org.babyfish.jimmer.sql.Id" ||
            annotation.simpleName == "Id"
        }
    }

    private fun isAutoGenerated(lsiField: LsiField): Boolean {
        return lsiField.annotations.any { annotation ->
            annotation.qualifiedName == "org.babyfish.jimmer.sql.GeneratedValue" ||
            annotation.simpleName == "GeneratedValue"
        }
    }

    private fun determineColumnType(lsiField: LsiField): String {
        val fieldType = lsiField.type?.qualifiedName ?: return "VARCHAR(255)"
        
        return when (fieldType) {
            "java.lang.String", "kotlin.String" -> "VARCHAR(255)"
            "java.lang.Long", "kotlin.Long", "long" -> "BIGINT"
            "java.lang.Integer", "kotlin.Int", "int" -> "INT"
            "java.lang.Boolean", "kotlin.Boolean", "boolean" -> "BOOLEAN"
            "java.math.BigDecimal" -> "DECIMAL(19,2)"
            "java.time.LocalDateTime" -> "TIMESTAMP"
            "java.time.LocalDate" -> "DATE"
            "java.time.LocalTime" -> "TIME"
            "java.util.UUID" -> "VARCHAR(36)"
            else -> {
                // 检查是否为枚举类型
                if (isEnumType(lsiField)) {
                    "VARCHAR(50)" // 枚举默认使用VARCHAR
                } else {
                    "VARCHAR(255)" // 默认类型
                }
            }
        }
    }

    private fun isEnumType(lsiField: LsiField): Boolean {
        // 通过LSI检查字段类型是否为枚举
        return lsiField.type?.let { type ->
            // 这里需要根据LSI的实际API来判断是否为枚举
            // 暂时使用简单的字符串匹配
            type.qualifiedName?.let { typeName ->
                // 检查类型名是否包含常见的枚举模式
                typeName.contains("Status") || 
                typeName.contains("Type") || 
                typeName.contains("State") ||
                typeName.endsWith("Enum")
            } ?: false
        } ?: false
    }

    private fun isNullable(lsiField: LsiField): Boolean {
        // 检查@Column注解的nullable属性
        val columnAnnotation = lsiField.annotations.find { annotation ->
            annotation.qualifiedName == "org.babyfish.jimmer.sql.Column" ||
            annotation.simpleName == "Column"
        }
        
        val columnNullable = columnAnnotation?.getAttribute("nullable") as? Boolean
        if (columnNullable != null) {
            return columnNullable
        }
        
        // 检查是否有@NotNull注解
        val hasNotNull = lsiField.annotations.any { annotation ->
            annotation.qualifiedName?.endsWith(".NotNull") == true ||
            annotation.simpleName == "NotNull"
        }
        
        if (hasNotNull) {
            return false
        }
        
        // 主键字段不可空
        if (isPrimaryKey(lsiField)) {
            return false
        }
        
        // Kotlin可空类型检查
        val fieldType = lsiField.type?.qualifiedName
        if (fieldType?.endsWith("?") == true) {
            return true
        }
        
        // 默认可空
        return true
    }

    private fun extractLength(lsiField: LsiField): Int {
        val columnAnnotation = lsiField.annotations.find { annotation ->
            annotation.qualifiedName == "org.babyfish.jimmer.sql.Column" ||
            annotation.simpleName == "Column"
        }
        
        return columnAnnotation?.getAttribute("length") as? Int ?: -1
    }

    private fun extractPrecision(lsiField: LsiField): Int {
        val columnAnnotation = lsiField.annotations.find { annotation ->
            annotation.qualifiedName == "org.babyfish.jimmer.sql.Column" ||
            annotation.simpleName == "Column"
        }
        
        return columnAnnotation?.getAttribute("precision") as? Int ?: -1
    }

    private fun extractScale(lsiField: LsiField): Int {
        val columnAnnotation = lsiField.annotations.find { annotation ->
            annotation.qualifiedName == "org.babyfish.jimmer.sql.Column" ||
            annotation.simpleName == "Column"
        }
        
        return columnAnnotation?.getAttribute("scale") as? Int ?: -1
    }

    private fun determineRelationshipType(lsiField: LsiField): RelationshipType? {
        return when {
            hasAnnotation(lsiField, "ManyToOne") -> RelationshipType.MANY_TO_ONE
            hasAnnotation(lsiField, "OneToMany") -> RelationshipType.ONE_TO_MANY
            hasAnnotation(lsiField, "ManyToMany") -> RelationshipType.MANY_TO_MANY
            hasAnnotation(lsiField, "OneToOne") -> RelationshipType.ONE_TO_ONE
            else -> null
        }
    }

    private fun hasAnnotation(lsiField: LsiField, annotationName: String): Boolean {
        return lsiField.annotations.any { annotation ->
            annotation.qualifiedName?.endsWith(".$annotationName") == true ||
            annotation.simpleName == annotationName
        }
    }

    private fun camelToSnakeCase(camelCase: String): String {
        return camelCase.replace(Regex("([a-z])([A-Z])"), "$1_$2").lowercase()
    }
}
package site.addzero.ksp.metadata.semantic.processor

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getAnnotationsByType
import com.google.devtools.ksp.getClassDeclarationByName
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.*
import site.addzero.ksp.metadata.semantic.SemanticMethodDefinition
import site.addzero.ksp.metadata.semantic.SemanticMappingProvider
import site.addzero.ksp.metadata.semantic.annotations.AutoSemantic
import site.addzero.ksp.metadata.semantic.annotations.SemanticVariation
import java.util.*

class MethodSemanticProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    private var invoked = false

    private val providers: List<SemanticMappingProvider> by lazy {
        ServiceLoader.load(SemanticMappingProvider::class.java, MethodSemanticProcessor::class.java.classLoader).toList()
    }

    private class RawCode(val code: String)

    @OptIn(KspExperimental::class)
    override fun process(resolver: Resolver): List<KSAnnotated> {
        if (invoked) return emptyList()
        invoked = true

        // 1. 获取所有显式标记了 @AutoSemantic 的类
        val annotatedClasses = resolver.getSymbolsWithAnnotation(AutoSemantic::class.qualifiedName!!)
            .filterIsInstance<KSClassDeclaration>()

        // 2. 获取所有包含 @SemanticVariation 方法的类 (自动识别)
        val variationClasses = resolver.getSymbolsWithAnnotation(SemanticVariation::class.qualifiedName!!)
            .filterIsInstance<KSFunctionDeclaration>()
            .mapNotNull { it.parentDeclaration as? KSClassDeclaration }

        // 3. 获取 SPI 声明要处理的类
        val spiClassNames = providers.flatMap { it.getSupportedClassNames() }.toSet()
        val spiClasses = spiClassNames.mapNotNull { resolver.getClassDeclarationByName(it) }

        // 合并去重
        val allTargetClasses = (annotatedClasses + variationClasses + spiClasses)
            .distinctBy { it.qualifiedName?.asString() }

        val ret = allTargetClasses.filter { !it.validate() }.toList()

        allTargetClasses.forEach { classDec ->
            generateSemanticExtensions(classDec)
        }

        return ret
    }

    @OptIn(KspExperimental::class)
    private fun generateSemanticExtensions(classDec: KSClassDeclaration) {
        val qualifiedName = classDec.qualifiedName?.asString() ?: return
        val allMappings = mutableMapOf<String, MutableList<SemanticMethodDefinition>>()

        // 从所有来源收集映射关系
        providers.forEach { provider ->
            provider.getMappings(qualifiedName)?.forEach { (originMethod, definitions) ->
                allMappings.getOrPut(originMethod) { mutableListOf() }.addAll(definitions)
            }
        }

        classDec.getAllFunctions().forEach { func ->
            val funcName = func.simpleName.asString()
            func.getAnnotationsByType(SemanticVariation::class).forEach { anno ->
                allMappings.getOrPut(funcName) { mutableListOf() }.add(
                    SemanticMethodDefinition(
                        newMethodName = anno.name,
                        fixedParameters = parseArgs(anno.args),
                        doc = anno.doc.takeIf { it.isNotBlank() }
                    )
                )
            }
        }

        if (allMappings.isEmpty()) return

        val packageName = classDec.packageName.asString()
        val className = classDec.simpleName.asString()
        val fileSpec = FileSpec.builder(packageName, "${className}SemanticExtensions")
            .addFileComment("Generated by Method Semanticizer. DO NOT EDIT.")

        allMappings.forEach { (originMethodName, definitions) ->
            val originMethod = classDec.getAllFunctions().find { it.simpleName.asString() == originMethodName } ?: return@forEach
            definitions.forEach { definition ->
                fileSpec.addFunction(buildSemanticFunction(classDec, originMethod, definition))
            }
        }

        try {
            fileSpec.build().writeTo(codeGenerator, Dependencies(true, classDec.containingFile!!))
        } catch (e: Exception) {
            // Ignore if file already exists in this round or target
        }
    }

    private fun parseArgs(args: Array<String>): Map<String, Any?> {
        return args.associate { arg ->
            val parts = arg.split("=", limit = 2)
            val key = parts[0].trim()
            val valueStr = parts.getOrNull(1)?.trim() ?: "null"
            key to inferValue(valueStr)
        }
    }

    private fun inferValue(value: String): Any? {
        if (value == "null") return null
        if (value == "true") return true
        if (value == "false") return false
        if (value.startsWith("'") && value.endsWith("'")) return value.substring(1, value.length - 1)
        if (value.startsWith("\"") && value.endsWith("\"")) return value.substring(1, value.length - 1)
        if (value.endsWith("L") || value.endsWith("l")) return value.dropLast(1).toLongOrNull() ?: value
        val intVal = value.toIntOrNull()
        if (intVal != null) return intVal
        if (value.contains(".")) return RawCode(value)
        return value
    }

    private fun buildSemanticFunction(
        classDec: KSClassDeclaration,
        originMethod: KSFunctionDeclaration,
        definition: SemanticMethodDefinition
    ): FunSpec {
        val receiverType = classDec.asType(emptyList()).toTypeName()
        val builder = FunSpec.builder(definition.newMethodName)
            .receiver(receiverType)
            .addModifiers(KModifier.PUBLIC)

        // 1. 继承泛型参数 (Type Parameters)
        val typeVariables = originMethod.typeParameters.map { it.toTypeVariableName() }
        builder.addTypeVariables(typeVariables)

        // 2. 继承修饰符 (Modifiers)
        if (originMethod.modifiers.contains(Modifier.SUSPEND)) builder.addModifiers(KModifier.SUSPEND)
        if (originMethod.modifiers.contains(Modifier.INLINE)) builder.addModifiers(KModifier.INLINE)
        if (originMethod.modifiers.contains(Modifier.INFIX)) builder.addModifiers(KModifier.INFIX)
        if (originMethod.modifiers.contains(Modifier.OPERATOR)) builder.addModifiers(KModifier.OPERATOR)

        if (definition.doc != null) builder.addKdoc(definition.doc!!)

        val fixedParamNames = definition.fixedParameters.keys
        originMethod.parameters.filter { it.name?.asString() !in fixedParamNames }.forEach { param ->
            builder.addParameter(ParameterSpec.builder(param.name!!.asString(), param.type.toTypeName()).build())
        }

        builder.returns(originMethod.returnType?.toTypeName() ?: UNIT)

        // 3. 构建调用体，显式传递泛型参数
        val codeBody = StringBuilder()
        if (originMethod.returnType?.resolve()?.declaration?.qualifiedName?.asString() != "kotlin.Unit") {
            codeBody.append("return ")
        }
        
        val typeArgs = if (typeVariables.isNotEmpty()) {
            typeVariables.joinToString(", ", prefix = "<", postfix = ">") { it.name }
        } else {
            ""
        }
        
        codeBody.append("%N$typeArgs(")

        val args = mutableListOf<Any>()
        args.add(originMethod.simpleName.asString())

        originMethod.parameters.forEachIndexed { index, param ->
            val pName = param.name!!.asString()
            if (pName in fixedParamNames) {
                codeBody.append("${pName} = %L")
                args.add(formatValue(definition.fixedParameters[pName]))
            } else {
                codeBody.append("${pName} = %N")
                args.add(pName)
            }
            if (index < originMethod.parameters.size - 1) {
                codeBody.append(", ")
            }
        }
        codeBody.append(")")
        builder.addStatement(codeBody.toString(), *args.toTypedArray())
        return builder.build()
    }

    private fun formatValue(value: Any?): String {
        return when (value) {
            is RawCode -> value.code
            is String -> "\"$value\""
            is Long -> "${value}L"
            is Int -> value.toString()
            is Boolean -> value.toString()
            null -> "null"
            else -> value.toString()
        }
    }
}

class MethodSemanticProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return MethodSemanticProcessor(environment.codeGenerator, environment.logger)
    }
}

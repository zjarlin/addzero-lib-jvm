package site.addzero.processor.feign

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import java.io.File

class FeignCodeGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val outputPackage: String,
    private val outputDir: String?
) {

    fun generate(meta: ControllerMeta) {
        val feignClientName = meta.className.replace("Controller", "FeignClient")
        val code = generateFeignCode(meta, feignClientName)

        if (!outputDir.isNullOrBlank()) {
            writeToCustomDir(feignClientName, code)
        } else {
            writeToKspOutput(feignClientName, code)
        }

        logger.info("[Controller2Feign] Generated FeignClient: $outputPackage.$feignClientName")
    }

    private fun generateFeignCode(meta: ControllerMeta, feignClientName: String): String {
        val serviceName = meta.className.replace("Controller", "")
            .replace(Regex("([a-z])([A-Z])"), "$1-$2")
            .lowercase()

        val basePath = meta.basePath.takeIf { it.isNotBlank() } ?: "/"

        val methodsCode = meta.methods.joinToString("\n\n") { generateMethod(it) }

        return """
package $outputPackage

import org.springframework.cloud.openfeign.FeignClient
import org.springframework.web.bind.annotation.*

/**
 * Feign Client for ${meta.className}
 * Generated by KSP - DO NOT MODIFY
 */
@FeignClient(name = "$serviceName", path = "$basePath")
interface $feignClientName {

$methodsCode

}
        """.trimIndent()
    }

    private fun generateMethod(method: MethodMeta): String {
        val annotation = when (method.httpMethod) {
            HttpMethod.GET -> "@GetMapping(\"${method.path}\")"
            HttpMethod.POST -> "@PostMapping(\"${method.path}\")"
            HttpMethod.PUT -> "@PutMapping(\"${method.path}\")"
            HttpMethod.DELETE -> "@DeleteMapping(\"${method.path}\")"
            HttpMethod.PATCH -> "@PatchMapping(\"${method.path}\")"
        }

        val params = method.parameters.joinToString(",\n        ") { param ->
            val paramAnno = when (param.annotation) {
                ParamAnnotation.PATH_VARIABLE -> "@PathVariable(\"${param.name}\")"
                ParamAnnotation.REQUEST_PARAM -> "@RequestParam(\"${param.name}\")"
                ParamAnnotation.REQUEST_BODY -> "@RequestBody"
                ParamAnnotation.REQUEST_HEADER -> "@RequestHeader(\"${param.name}\")"
                ParamAnnotation.NONE -> ""
            }
            "$paramAnno ${param.name}: ${simplifyType(param.type)}"
        }

        val paramBlock = if (params.isNotBlank()) "\n        $params\n    " else ""
        val returnType = simplifyType(method.returnType)

        return """    $annotation
    fun ${method.name}($paramBlock): $returnType"""
    }

    private fun simplifyType(fullType: String): String {
        return fullType
            .replace("java.lang.", "")
            .replace("java.util.", "")
            .replace("kotlin.collections.", "")
            .replace("kotlin.", "")
    }

    private fun writeToKspOutput(fileName: String, code: String) {
        codeGenerator.createNewFile(
            dependencies = Dependencies(false),
            packageName = outputPackage,
            fileName = fileName
        ).use { it.write(code.toByteArray()) }
    }

    private fun writeToCustomDir(fileName: String, code: String) {
        val packagePath = outputPackage.replace('.', File.separatorChar)
        val outputPath = File(outputDir, packagePath)
        outputPath.mkdirs()

        val file = File(outputPath, "$fileName.kt")
        file.writeText(code)
        logger.info("[Controller2Feign] Written to: ${file.absolutePath}")
    }
}

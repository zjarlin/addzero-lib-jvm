package site.addzero.apt.dict.processor

import site.addzero.apt.dict.dsl.DslTemplateConfig
import site.addzero.apt.dict.dsl.TranslationType
import javax.lang.model.element.TypeElement

/**
 * Java Enhanced Entity code generator for compile-time dictionary translation
 * 
 * This class generates pure Java code using Kotlin multiline strings.
 * It's responsible for:
 * 1. Generating enhanced entity classes in Java
 * 2. Managing Java-style getters and setters
 * 3. Adding Java translation methods and logic
 * 4. Implementing Java metadata generation
 * 5. Supporting automatic nested structure and List handling
 */
class JavaEntityEnhancer {
    
    /**
     * Generates an enhanced entity Java class using Kotlin multiline strings
     * 
     * @param originalClass The original entity class element
     * @param dslConfig DSL configuration for translation rules
     * @param packageName Target package name for generated class
     * @return Generated Java source code as string
     */
    fun generateEnhancedEntityJava(
        originalClass: TypeElement,
        dslConfig: DslTemplateConfig,
        packageName: String
    ): String {
        val originalClassName = originalClass.simpleName.toString()
        val enhancedClassName = "${originalClassName}Enhanced"
        
        return generateJavaClassCode(
            packageName = packageName,
            originalClassName = originalClassName,
            enhancedClassName = enhancedClassName,
            dslConfig = dslConfig
        )
    }
    
    /**
     * 公开方法供测试使用
     */
    fun generateJavaClassCode(
        packageName: String,
        originalClassName: String,
        enhancedClassName: String,
        dslConfig: DslTemplateConfig
    ): String {
        val translationFields = extractTranslationFields(dslConfig)
        val systemDictCodes = extractSystemDictCodes(dslConfig)
        val tableDictConfigs = extractTableDictConfigs(dslConfig)
        
        return """
package $packageName;

import site.addzero.apt.dict.service.TransApi;
import site.addzero.apt.dict.service.DictModel;
import java.util.*;
import java.util.concurrent.CompletableFuture;

/**
 * Enhanced version of $originalClassName with compile-time dictionary translation support.
 * 
 * This class extends the original entity with additional translation fields and methods.
 * Translation is performed at compile-time using APT (Annotation Processing Tool) for optimal performance.
 * 
 * Inheritance: $enhancedClassName extends $originalClassName (T->R mapping)
 * 
 * Features:
 * - Zero runtime reflection overhead
 * - Batch translation support for N+1 query elimination  
 * - Type-safe translation field access
 * - Automatic nested structure and List handling
 * - Inherits all original entity properties and methods
 * 
 * Generated by JavaEntityEnhancer at compile time.
 */
public class $enhancedClassName extends $originalClassName {
    
    // Generated translation fields
${generateTranslationFields(translationFields)}
    
    /**
     * Default constructor that calls parent constructor
     */
    public $enhancedClassName() {
        super();
    }
    
    // Getters and setters for translation fields
${generateGettersAndSetters(translationFields)}
    
    /**
     * Performs batch dictionary translation for all annotated fields.
     * Automatically handles nested objects and List structures.
     * Uses batch operations to eliminate N+1 query problems.
     * Since this class extends the original entity, it uses its own field values.
     * 
     * @param transApi The translation API to use for batch translation
     */
    public void translate(TransApi transApi) {
        // First translate nested structures recursively
        translateNestedStructures(transApi);
        
${generateSystemDictTranslation(dslConfig)}
        
${generateTableDictTranslation(dslConfig)}
    }
    
    /**
     * Performs asynchronous batch dictionary translation for all annotated fields.
     * Uses CompletableFuture for non-blocking translation operations.
     * 
     * @param transApi The translation API to use for batch translation
     * @return CompletableFuture that completes when translation is finished
     */
    public CompletableFuture<Void> translateAsync(TransApi transApi) {
        return CompletableFuture.runAsync(() -> translate(transApi));
    }
    
    /**
     * Populates translation fields from a context map.
     * 
     * @param context Map containing translation data keyed by field names
     */
    public void populateFromContext(Map<String, Object> context) {
${generatePopulateFromContext(translationFields)}
    }
    
    /**
     * Handles translation of nested objects and List structures automatically.
     * This method uses reflection to detect and process complex nested scenarios.
     */
    private void translateNestedStructures(TransApi transApi) {
        try {
            // Use reflection to find all fields that might contain nested @DictTranslate objects
            java.lang.reflect.Field[] fields = this.getClass().getSuperclass().getDeclaredFields();
            
            for (java.lang.reflect.Field field : fields) {
                field.setAccessible(true);
                Object fieldValue = field.get(this);
                
                if (fieldValue == null) continue;
                
                // Handle List fields
                if (fieldValue instanceof java.util.List) {
                    java.util.List<?> list = (java.util.List<?>) fieldValue;
                    for (Object item : list) {
                        if (item != null && hasTranslateMethod(item.getClass())) {
                            invokeTranslateMethod(item, transApi);
                        }
                    }
                }
                // Handle nested object fields
                else if (hasTranslateMethod(fieldValue.getClass())) {
                    invokeTranslateMethod(fieldValue, transApi);
                }
            }
        } catch (Exception e) {
            // Log error but don't fail the translation
            System.err.println("Warning: Error during nested structure translation: " + e.getMessage());
        }
    }
    
    /**
     * Checks if a class has a translate method (indicating it's a @DictTranslate enhanced class)
     */
    private boolean hasTranslateMethod(Class<?> clazz) {
        try {
            clazz.getMethod("translate", TransApi.class);
            return true;
        } catch (NoSuchMethodException e) {
            return false;
        }
    }
    
    /**
     * Invokes the translate method on an object
     */
    private void invokeTranslateMethod(Object obj, TransApi transApi) {
        try {
            java.lang.reflect.Method translateMethod = obj.getClass().getMethod("translate", TransApi.class);
            translateMethod.invoke(obj, transApi);
        } catch (Exception e) {
            System.err.println("Warning: Failed to invoke translate method on " + obj.getClass().getSimpleName() + ": " + e.getMessage());
        }
    }
    
    // Static metadata constants
    
    /**
     * DSL configuration metadata for this enhanced entity
     */
    public static final String DSL_CONFIG = "$originalClassName";
    
    /**
     * System dictionary codes used by this entity
     */
    public static final Set<String> SYSTEM_DICT_CODES = new HashSet<String>() {{
${generateSystemDictCodesInit(systemDictCodes)}
    }};
    
    /**
     * Table dictionary configurations used by this entity
     */
    public static final Set<String> TABLE_DICT_CONFIGS = new HashSet<String>() {{
${generateTableDictConfigsInit(tableDictConfigs)}
    }};
}
        """.trimIndent()
    }
    
    /**
     * 公开方法供测试使用 - 生成系统字典翻译代码
     */
    fun generateSystemDictTranslation(dslConfig: DslTemplateConfig): String {
        val systemDictFields = mutableListOf<Pair<String, String>>() // fieldName to dictCode
        
        dslConfig.translationRules.forEach { rule ->
            rule.fieldRules.forEach { fieldRule ->
                fieldRule.dictConfigs.forEach { dictConfig ->
                    if (dictConfig.type.name == "SYSTEM_DICT" && dictConfig.dictCode.isNotEmpty()) {
                        systemDictFields.add(fieldRule.fieldName to dictConfig.dictCode)
                    }
                }
            }
        }
        
        if (systemDictFields.isEmpty()) return ""
        
        val dictCodes = systemDictFields.map { it.second }.distinct().joinToString(",")
        
        return """
        // System dictionary batch translation
        String systemDictCodes = "$dictCodes";
        List<String> systemKeys = new ArrayList<>();
        
${systemDictFields.joinToString("\n") { (fieldName, _) ->
            val getterName = "get${fieldName.capitalize()}"
            """        if (this.$getterName() != null) {
            systemKeys.add(this.$getterName().toString());
        }"""
        }}
        
        if (!systemKeys.isEmpty()) {
            List<DictModel> systemResults = transApi.translateDictBatchCode2name(systemDictCodes, String.join(",", systemKeys));
            Map<String, DictModel> systemResultMap = new HashMap<>();
            for (DictModel model : systemResults) {
                systemResultMap.put(model.getDictCode() + ":" + model.getValue(), model);
            }
            
${systemDictFields.joinToString("\n") { (fieldName, dictCode) ->
            val getterName = "get${fieldName.capitalize()}"
            val setterName = "set${fieldName.replace(".", "_").replace("[]", "_list")}Text".let { 
                "set${it.capitalize()}"
            }
            """            if (this.$getterName() != null) {
                String key = "$dictCode:" + this.$getterName().toString();
                DictModel result = systemResultMap.get(key);
                if (result != null) {
                    this.$setterName(result.getLabel());
                }
            }"""
        }}
        }
        """.trimIndent()
    }
    
    /**
     * 公开方法供测试使用 - 生成表字典翻译代码
     */
    fun generateTableDictTranslation(dslConfig: DslTemplateConfig): String {
        val tableDictFields = mutableListOf<TableDictField>()
        
        dslConfig.translationRules.forEach { rule ->
            rule.fieldRules.forEach { fieldRule ->
                fieldRule.dictConfigs.forEach { dictConfig ->
                    if (dictConfig.type.name == "TABLE_DICT" && dictConfig.table.isNotEmpty()) {
                        tableDictFields.add(TableDictField(
                            fieldName = fieldRule.fieldName,
                            targetFieldName = fieldRule.targetFieldName,
                            table = dictConfig.table,
                            codeColumn = dictConfig.codeColumn,
                            nameColumn = dictConfig.nameColumn
                        ))
                    }
                }
            }
        }
        
        if (tableDictFields.isEmpty()) return ""
        
        // 按表分组
        val fieldsByTable = tableDictFields.groupBy { "${it.table}:${it.codeColumn}:${it.nameColumn}" }
        
        return fieldsByTable.map { (tableKey, fields) ->
            val parts = tableKey.split(":")
            val table = parts[0]
            val codeColumn = parts[1]
            val nameColumn = parts[2]
            val tableVarName = "tableKeys_${table.replace(".", "_")}"
            
            """
        // Table dictionary batch translation for $table
        List<String> $tableVarName = new ArrayList<>();
        
${fields.joinToString("\n") { field ->
            val getterName = "get${field.fieldName.capitalize()}"
            """        if (this.$getterName() != null) {
            $tableVarName.add(this.$getterName().toString());
        }"""
        }}
        
        if (!$tableVarName.isEmpty()) {
            List<Map<String, Object>> tableResults = transApi.translateTableBatchCode2name("$table", "$nameColumn", "$codeColumn", String.join(",", $tableVarName));
            Map<String, Map<String, Object>> tableResultMap = new HashMap<>();
            for (Map<String, Object> row : tableResults) {
                Object codeValue = row.get("$codeColumn");
                if (codeValue != null) {
                    tableResultMap.put(codeValue.toString(), row);
                }
            }
            
${fields.joinToString("\n") { field ->
            val getterName = "get${field.fieldName.capitalize()}"
            val setterName = "set${field.targetFieldName.capitalize()}"
            """            if (this.$getterName() != null) {
                String key = this.$getterName().toString();
                Map<String, Object> result = tableResultMap.get(key);
                if (result != null) {
                    Object nameValue = result.get("$nameColumn");
                    if (nameValue != null) {
                        this.$setterName(nameValue.toString());
                    }
                }
            }"""
        }}
        }
            """.trimIndent()
        }.joinToString("\n")
    }
    
    /**
     * 从 DSL 配置中提取翻译字段信息
     */
    private fun extractTranslationFields(dslConfig: DslTemplateConfig): List<TranslationField> {
        val fields = mutableListOf<TranslationField>()
        
        dslConfig.translationRules.forEach { rule ->
            rule.fieldRules.forEach { fieldRule ->
                fields.add(TranslationField(
                    name = fieldRule.targetFieldName,
                    sourceField = fieldRule.fieldName
                ))
            }
        }
        
        return fields
    }
    
    /**
     * 提取系统字典代码
     */
    private fun extractSystemDictCodes(dslConfig: DslTemplateConfig): Set<String> {
        val codes = mutableSetOf<String>()
        
        dslConfig.translationRules.forEach { rule ->
            rule.fieldRules.forEach { fieldRule ->
                fieldRule.dictConfigs.forEach { dictConfig ->
                    if (dictConfig.type.name == "SYSTEM_DICT" && dictConfig.dictCode.isNotEmpty()) {
                        codes.add(dictConfig.dictCode)
                    }
                }
            }
        }
        
        return codes
    }
    
    /**
     * 提取表字典配置
     */
    private fun extractTableDictConfigs(dslConfig: DslTemplateConfig): Set<String> {
        val configs = mutableSetOf<String>()
        
        dslConfig.translationRules.forEach { rule ->
            rule.fieldRules.forEach { fieldRule ->
                fieldRule.dictConfigs.forEach { dictConfig ->
                    if (dictConfig.type.name == "TABLE_DICT" && dictConfig.table.isNotEmpty()) {
                        configs.add("${dictConfig.table}:${dictConfig.codeColumn}:${dictConfig.nameColumn}")
                    }
                }
            }
        }
        
        return configs
    }
    
    /**
     * 生成翻译字段声明
     */
    private fun generateTranslationFields(fields: List<TranslationField>): String {
        return fields.joinToString("\n") { field ->
            "    private String ${field.name};"
        }
    }
    
    /**
     * 生成 getter 和 setter 方法
     */
    private fun generateGettersAndSetters(fields: List<TranslationField>): String {
        return fields.joinToString("\n\n") { field ->
            val capitalizedName = field.name.capitalize()
            """
    /**
     * Gets the translated value for ${field.sourceField}
     * @return the translated value
     */
    public String get$capitalizedName() {
        return this.${field.name};
    }
    
    /**
     * Sets the translated value for ${field.sourceField}
     * @param ${field.name} the translated value to set
     */
    public void set$capitalizedName(String ${field.name}) {
        this.${field.name} = ${field.name};
    }
            """.trimIndent()
        }
    }
    
    /**
     * 生成 populateFromContext 方法内容
     */
    private fun generatePopulateFromContext(fields: List<TranslationField>): String {
        return fields.joinToString("\n") { field ->
            val setterName = "set${field.name.capitalize()}"
            """        Object ${field.name}Value = context.get("${field.name}");
        if (${field.name}Value instanceof String) {
            this.$setterName((String) ${field.name}Value);
        }"""
        }
    }
    
    /**
     * 生成系统字典代码初始化
     */
    private fun generateSystemDictCodesInit(codes: Set<String>): String {
        return codes.joinToString("\n") { code ->
            """        add("$code");"""
        }
    }
    
    /**
     * 生成表字典配置初始化
     */
    private fun generateTableDictConfigsInit(configs: Set<String>): String {
        return configs.joinToString("\n") { config ->
            """        add("$config");"""
        }
    }
    
    /**
     * Capitalizes the first letter of a string
     */
    private fun String.capitalize(): String {
        return if (isEmpty()) this else substring(0, 1).uppercase() + substring(1)
    }
    
    /**
     * 翻译字段信息
     */
    data class TranslationField(
        val name: String,
        val sourceField: String
    )
    
    /**
     * 表字典字段信息
     */
    data class TableDictField(
        val fieldName: String,
        val targetFieldName: String,
        val table: String,
        val codeColumn: String,
        val nameColumn: String
    )
}
package site.addzero.apt.dict.processor.generator

/**
 * 字典转换器生成器
 * 生成实现LsiDictConvertor接口的转换器类
 */
object DictConvertorGenerator {
    
    /**
     * 生成Convertor类
     * 
     * @param packageName 包名
     * @param originalClassName 原始类名
     * @param dictFieldsInfo 字典字段信息
     * @return 生成的Java代码
     */
    fun generateConvertor(packageName: String, originalClassName: String, dictFieldsInfo: List<DictFieldInfo>): String {
        val dtoClassName = "${originalClassName}DictDTO"
        val convertorClassName = "${originalClassName}Convertor"
        
        return """
package $packageName;

import site.addzero.dict.trans.inter.LsiDictConvertor;
import site.addzero.dict.trans.inter.SqlExecutor;
import site.addzero.dict.trans.inter.TransTask;
import site.addzero.dict.trans.inter.DictTranslationFactory;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Dictionary convertor for ${originalClassName}
 * Generated by DictTranslateProcessor
 * 
 * Uses compile-time generated tasks with expression-based value extraction
 * Leverages singleton factory with Caffeine cache for optimal performance
 */
public class $convertorClassName implements LsiDictConvertor<$originalClassName, $dtoClassName> {
    
    public $convertorClassName(SqlExecutor sqlExecutor) {
        // Initialize the singleton factory
        DictTranslationFactory.initialize(sqlExecutor);
    }
    
    @Override
    public $dtoClassName code2name($originalClassName entity) {
        if (entity == null) {
            return null;
        }
        
        return code2name(Collections.singletonList(entity)).get(0);
    }
    
    /**
     * Batch code2name translation for multiple entities
     * Uses compile-time generated tasks with expression-based value extraction
     * Leverages singleton factory with Caffeine cache for optimal performance
     */
    public List<$dtoClassName> code2name(List<$originalClassName> entities) {
        if (entities == null || entities.isEmpty()) {
            return new ArrayList<>();
        }
        
        // Convert to DTOs
        List<$dtoClassName> dtos = entities.stream()
            .filter(Objects::nonNull)
            .map($dtoClassName::new)
            .collect(Collectors.toList());
        
        // Get compile-time generated translation tasks
        List<TransTask> tasks = getTranslationTasks();
        
        // Execute batch translation using singleton factory
        try {
            CompletableFuture<Map<String, String>> future = 
                DictTranslationFactory.processTranslationTasks(tasks, this::extractValue);
            Map<String, String> translationResults = future.get();
            
            // Apply translations using generated code
            applyTranslationResults(dtos, translationResults);
            
        } catch (Exception e) {
            throw new RuntimeException("Batch translation failed", e);
        }
        
        return dtos;
    }
    
    @Override
    public $originalClassName name2code($dtoClassName dto) {
        if (dto == null) {
            return null;
        }
        
        // Create original entity
        $originalClassName entity = new $originalClassName();
        
        // Copy basic properties
        copyBasicProperties(dto, entity);
        
        // Perform reverse translation (name -> code)
        performReverseTranslation(dto, entity);
        
        return entity;
    }
    
    /**
     * Get compile-time generated translation tasks
     */
    private List<TransTask> getTranslationTasks() {
        List<TransTask> tasks = new ArrayList<>();
        ${generateTranslationTasks(dictFieldsInfo)}
        return tasks;
    }
    
    /**
     * Extract value using expression (used by singleton factory)
     */
    private Object extractValue(String expression) {
        // This method will be generated with specific extraction logic
        ${generateValueExtractionLogic(dictFieldsInfo)}
        return null; // Default fallback
    }
    
    /**
     * Apply translation results using task IDs
     */
    private void applyTranslationResults(
        List<$dtoClassName> dtos, 
        Map<String, String> translationResults
    ) {
        ${generateTranslationResultApplication(dictFieldsInfo, dtoClassName)}
    }

    
    /**
     * Copy basic properties from DTO to entity
     */
    private void copyBasicProperties($dtoClassName dto, $originalClassName entity) {
        // Copy logic would be generated based on actual fields
    }
    
    /**
     * Perform reverse translation (name -> code)
     */
    private void performReverseTranslation($dtoClassName dto, $originalClassName entity) {
        // Reverse translation implementation
        // This would query dictionaries to find codes for given names
    }
    
    /**
     * Utility class for Pair (since Java doesn't have built-in Pair)
     */
    private static class Pair<K, V> {
        private final K key;
        private final V value;
        
        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }
        
        public K getKey() { return key; }
        public V getValue() { return value; }
    }
}
        """.trimIndent()
    }
    
    /**
     * 生成编译时翻译任务
     */
    private fun generateTranslationTasks(dictFieldsInfo: List<DictFieldInfo>): String {
        return dictFieldsInfo.joinToString("\n        ") { fieldInfo ->
            val valueExpression = generateFieldAccessorCode(fieldInfo.fieldPath, "dto")
            val setterExpression = generateFieldSetterCode(fieldInfo.translationFieldName, "dto", "translatedValue")
            
            """
        tasks.add(new TransTask(
            "${fieldInfo.fieldName}_task",
            "${fieldInfo.fieldPath}",
            "$valueExpression",
            "${fieldInfo.dictType}",
            "${fieldInfo.dictConfig}",
            "$setterExpression",
            "${fieldInfo.nestedClassPrefix}",
            0
        ));
            """.trimIndent()
        }
    }

    /**
     * 生成值提取逻辑
     */
    private fun generateValueExtractionLogic(dictFieldsInfo: List<DictFieldInfo>): String {
        return dictFieldsInfo.joinToString("\n        ") { fieldInfo ->
            val valueExpression = generateFieldAccessorCode(fieldInfo.fieldPath, "dto")
            
            """
        if ("$valueExpression".equals(expression)) {
            return $valueExpression;
        }
            """.trimIndent()
        }
    }

    /**
     * 生成翻译结果应用代码
     */
    private fun generateTranslationResultApplication(dictFieldsInfo: List<DictFieldInfo>, dtoClassName: String): String {
        return dictFieldsInfo.joinToString("\n        ") { fieldInfo ->
            val setterCode = generateFieldSetterCode(fieldInfo.translationFieldName, "dto", "translatedValue")
            
            """
        // Apply translation for task: ${fieldInfo.fieldName}_task
        String ${fieldInfo.fieldName}Result = translationResults.get("${fieldInfo.fieldName}_task");
        if (${fieldInfo.fieldName}Result != null) {
            for ($dtoClassName dto : dtos) {
                String translatedValue = ${fieldInfo.fieldName}Result;
                $setterCode;
            }
        }
            """.trimIndent()
        }
    }

    /**
     * 生成字段访问代码（支持嵌套）
     */
    private fun generateFieldAccessorCode(fieldPath: String, objectName: String): String {
        val parts = fieldPath.split(".")
        if (parts.size == 1) {
            // 简单字段
            val capitalizedName = parts[0].replaceFirstChar { it.uppercase() }
            return "$objectName.get$capitalizedName()"
        } else {
            // 嵌套字段
            var accessorChain = objectName
            parts.forEach { part ->
                val capitalizedPart = part.replaceFirstChar { it.uppercase() }
                accessorChain = "$accessorChain.get$capitalizedPart()"
            }
            return accessorChain
        }
    }

    /**
     * 生成字段设置代码（支持嵌套）
     */
    private fun generateFieldSetterCode(fieldPath: String, objectName: String, valueName: String): String {
        val parts = fieldPath.split(".")
        if (parts.size == 1) {
            // 简单字段
            val capitalizedName = parts[0].replaceFirstChar { it.uppercase() }
            return "$objectName.set$capitalizedName($valueName)"
        } else {
            // 嵌套字段 - 需要先获取嵌套对象，然后设置字段
            val nestedParts = parts.dropLast(1)
            val fieldName = parts.last()
            
            var accessorChain = objectName
            nestedParts.forEach { part ->
                val capitalizedPart = part.replaceFirstChar { it.uppercase() }
                accessorChain = "$accessorChain.get$capitalizedPart()"
            }
            
            val capitalizedFieldName = fieldName.replaceFirstChar { it.uppercase() }
            return "if ($accessorChain != null) { $accessorChain.set$capitalizedFieldName($valueName); }"
        }
    }
    

}

/**
 * 字典字段信息
 */
data class DictFieldInfo(
    val fieldName: String,
    val fieldType: String,
    val translationFieldName: String,
    val dictType: String, // "system" or "table"
    val dictConfig: String, // dicCode or "table|codeColumn|nameColumn|whereCondition"
    val nestedClassPrefix: String = "", // 嵌套类前缀，如 "ComplexNestedEntity.DeviceInfo.Location"
    val fieldPath: String = fieldName // 字段路径，支持嵌套访问
)
package site.addzero.apt.dict.processor.generator

import site.addzero.util.lsi.clazz.LsiClass
import site.addzero.util.lsi.field.LsiField

/**
 * 字典DTO生成器
 * 生成独立的DictDTO类，支持递归嵌套对象处理
 */
object DictDtoGenerator {
    
    /**
     * 生成DictDTO类
     * 
     * @param packageName 包名
     * @param lsiClass LSI类信息
     * @param allFields 所有字段
     * @param dictFields 字典字段
     * @return 生成的Java代码
     */
    fun generateDictDTO(packageName: String, lsiClass: LsiClass, allFields: List<LsiField>, dictFields: List<LsiField>): String {
        val originalClassName = lsiClass.name ?: "Unknown"
        val dtoClassName = "${originalClassName}DictDTO"
        
        // 转换 LsiField 为 DictFieldInfo
        val dictFieldsInfo = convertLsiFieldsToDictFieldInfo(dictFields)
        
        return """
package $packageName;

import lombok.Data;
import lombok.EqualsAndHashCode;

/**
 * Dictionary DTO for ${originalClassName}
 * Generated by DictTranslateProcessor
 * 
 * Extends original entity and adds translation fields:
${dictFieldsInfo.joinToString("\n") { " * - ${it.fieldName} -> ${it.translationFieldName}" }}
 */
@Data
@EqualsAndHashCode(callSuper = true)
public class $dtoClassName extends $originalClassName {
    
${generateTranslationFields(dictFieldsInfo)}
    
    /**
     * Default constructor
     */
    public $dtoClassName() {
        super();
    }
    
    /**
     * Constructor from original entity
     */
    public $dtoClassName($originalClassName original) {
        super();
        copyFromOriginal(original);
    }
    
    /**
     * Copy properties from original entity
     */
    private void copyFromOriginal($originalClassName original) {
        if (original == null) return;
        // Copy logic would be generated based on actual fields
    }
}
        """.trimIndent()
    }
    
    /**
     * 生成翻译字段
     */
    private fun generateTranslationFields(dictFieldsInfo: List<DictFieldInfo>): String {
        return dictFieldsInfo.joinToString("\n\n") { fieldInfo ->
            """
    /**
     * Dictionary translation for field: ${fieldInfo.fieldName}
     * ${fieldInfo.dictType}: ${fieldInfo.dictConfig}
     */
    private String ${fieldInfo.translationFieldName};
            """.trimIndent()
        }
    }
    
    /**
     * 将 LsiField 列表转换为 DictFieldInfo 列表
     */
    private fun convertLsiFieldsToDictFieldInfo(dictFields: List<LsiField>): List<DictFieldInfo> {
        return dictFields.mapNotNull { field ->
            val dictAnnotation = field.annotations.find { it.simpleName == "Dict" }
            if (dictAnnotation != null) {
                val fieldName = field.name ?: "unknown"
                val fieldType = field.type?.name ?: "Object"
                val translationFieldName = "${fieldName}Name"
                
                // 从注解中提取字典配置
                val dictType = dictAnnotation.getAttribute("type")?.toString() ?: "system"
                val dictConfig = when (dictType) {
                    "system" -> dictAnnotation.getAttribute("dicCode")?.toString() ?: ""
                    "table" -> {
                        val table = dictAnnotation.getAttribute("table")?.toString() ?: ""
                        val codeColumn = dictAnnotation.getAttribute("codeColumn")?.toString() ?: "code"
                        val nameColumn = dictAnnotation.getAttribute("nameColumn")?.toString() ?: "name"
                        val whereCondition = dictAnnotation.getAttribute("whereCondition")?.toString() ?: ""
                        "$table|$codeColumn|$nameColumn|$whereCondition"
                    }
                    else -> ""
                }
                
                DictFieldInfo(
                    fieldName = fieldName,
                    fieldType = fieldType,
                    translationFieldName = translationFieldName,
                    dictType = dictType,
                    dictConfig = dictConfig
                )
            } else {
                null
            }
        }
    }

    /**
     * 将数据库列名转换为驼峰命名
     * 例如: test_column -> testColumn
     */
    fun convertToCamelCase(columnName: String): String {
        return columnName.split("_")
            .mapIndexed { index, part ->
                if (index == 0) part.lowercase()
                else part.lowercase().replaceFirstChar { it.uppercase() }
            }
            .joinToString("")
    }
}
package site.addzero.apt.dict.processor.generator

import site.addzero.util.lsi.clazz.LsiClass
import site.addzero.util.lsi.field.LsiField

/**
 * 字典DTO生成器
 * 生成独立的DictDTO类，支持嵌套对象和集合的递归处理
 */
object DictDtoGenerator {
    
    /**
     * 生成DictDTO类
     * 
     * @param packageName 包名
     * @param originalClass 原始实体类
     * @param allFields 所有字段（包括非Dict字段）
     * @param dictFields 包含@Dict注解的字段
     * @return 生成的Java代码
     */
    fun generateDictDTO(packageName: String, originalClass: LsiClass, allFields: List<LsiField>, dictFields: List<LsiField>): String {
        val originalClassName = originalClass.name ?: "Unknown"
        val dtoClassName = "${originalClassName}DictDTO"
        
        return """
package $packageName;

import lombok.Data;
import java.util.*;

/**
 * Dictionary DTO for ${originalClassName}
 * Generated by DictTranslateProcessor
 * 
 * Independent DTO with recursive nested object support:
${allFields.joinToString("\n") { " * - ${generateFieldComment(it)}" }}
 * 
 * Dictionary translation fields:
${dictFields.joinToString("\n") { " * - ${generateDictFieldComment(it)}" }}
 */
@Data
public class $dtoClassName {
    
${generateAllFields(allFields)}
    
${generateTranslationFields(dictFields)}
    
    /**
     * Default constructor
     */
    public $dtoClassName() {
        // Default constructor
    }
    
    /**
     * Constructor with field initialization
     */
    public $dtoClassName(${generateConstructorParameters(allFields)}) {
${generateConstructorBody(allFields)}
    }
    
${generateUtilityMethods(originalClassName, allFields)}
}
        """.trimIndent()
    }
    
    /**
     * 生成所有字段（包括递归处理嵌套对象和集合）
     */
    private fun generateAllFields(allFields: List<LsiField>): String {
        return allFields.joinToString("\n    ") { field ->
            val fieldName = field.name ?: "unknown"
            val dtoFieldType = convertToDtoType(field)
            val comment = generateFieldComment(field)
            
            """
    /**
     * $comment
     */
    private $dtoFieldType $fieldName;
            """.trimIndent()
        }
    }
    
    /**
     * 生成翻译字段
     */
    private fun generateTranslationFields(dictFields: List<LsiField>): String {
        return dictFields.joinToString("\n    ") { field ->
            generateTranslationField(field)
        }
    }
    
    /**
     * 生成单个翻译字段
     */
    private fun generateTranslationField(field: LsiField): String {
        val fieldName = field.name ?: "unknown"
        val dictAnnotation = field.annotations.find { it.simpleName == "Dict" }
        
        if (dictAnnotation == null) {
            return "    // No @Dict annotation found for field: $fieldName"
        }
        
        // 检查是否有serializationAlias
        val serializationAlias = dictAnnotation.getAttribute("serializationAlias") as? String
        val nameColumn = dictAnnotation.getAttribute("nameColumn") as? String
        
        val translationFieldName = when {
            !serializationAlias.isNullOrEmpty() -> serializationAlias
            !nameColumn.isNullOrEmpty() -> nameColumn
            else -> "${fieldName}Text"
        }
        
        return """
    /**
     * Dictionary translation text for $fieldName
     */
    private String $translationFieldName;
        """.trimIndent()
    }
    
    /**
     * 将原始字段类型转换为DTO类型
     * 支持嵌套对象和集合的递归处理
     */
    private fun convertToDtoType(field: LsiField): String {
        val originalType = field.typeName ?: "Object"
        
        return when {
            // 处理集合类型：List<Role> -> List<RoleDictDTO>
            field.isCollectionType && originalType.contains("<") -> {
                val collectionType = originalType.substringBefore("<")
                val elementType = originalType.substringAfter("<").substringBefore(">")
                val dtoElementType = if (isCustomClass(elementType)) "${elementType}DictDTO" else elementType
                "$collectionType<$dtoElementType>"
            }
            // 处理嵌套对象：Dept -> DeptDictDTO
            field.isNestedObject || isCustomClass(originalType) -> {
                "${originalType}DictDTO"
            }
            // 基本类型保持不变
            else -> originalType
        }
    }
    
    /**
     * 判断是否为自定义类（需要生成DTO的类）
     */
    private fun isCustomClass(typeName: String): Boolean {
        return when (typeName) {
            "String", "Integer", "Long", "Double", "Float", "Boolean", 
            "int", "long", "double", "float", "boolean",
            "Date", "LocalDateTime", "LocalDate", "BigDecimal" -> false
            else -> !typeName.startsWith("java.") && !typeName.startsWith("javax.")
        }
    }
    
    /**
     * 生成构造函数参数
     */
    private fun generateConstructorParameters(allFields: List<LsiField>): String {
        return allFields.joinToString(", ") { field ->
            val fieldName = field.name ?: "unknown"
            val dtoFieldType = convertToDtoType(field)
            "$dtoFieldType $fieldName"
        }
    }
    
    /**
     * 生成构造函数体
     */
    private fun generateConstructorBody(allFields: List<LsiField>): String {
        return allFields.joinToString("\n") { field ->
            val fieldName = field.name ?: "unknown"
            "        this.$fieldName = $fieldName;"
        }
    }
    
    /**
     * 生成工具方法
     */
    private fun generateUtilityMethods(originalClassName: String, allFields: List<LsiField>): String {
        return """
    /**
     * Create DTO from original entity using DictClassHelperIocContext
     */
    public static ${originalClassName}DictDTO fromOriginal($originalClassName original) {
        if (original == null) return null;
        
        ${originalClassName}DictDTO dto = new ${originalClassName}DictDTO();
        ${generateFieldCopyLogic(allFields)}
        return dto;
    }
    
    /**
     * Convert DTO back to original entity
     */
    public $originalClassName toOriginal() {
        $originalClassName original = new $originalClassName();
        ${generateReverseFieldCopyLogic(allFields)}
        return original;
    }
        """.trimIndent()
    }
    
    /**
     * 生成字段复制逻辑
     */
    private fun generateFieldCopyLogic(allFields: List<LsiField>): String {
        return allFields.joinToString("\n        ") { field ->
            val fieldName = field.name ?: "unknown"
            val originalType = field.typeName ?: "Object"
            val dtoType = convertToDtoType(field)
            
            when {
                // 集合类型的递归处理
                field.isCollectionType && dtoType != originalType -> {
                    val elementType = originalType.substringAfter("<").substringBefore(">")
                    """
        if (original.get${fieldName.replaceFirstChar { it.uppercase() }}() != null) {
            List<${elementType}DictDTO> ${fieldName}List = new ArrayList<>();
            for (${elementType} item : original.get${fieldName.replaceFirstChar { it.uppercase() }}()) {
                ${fieldName}List.add(${elementType}DictDTO.fromOriginal(item));
            }
            dto.set${fieldName.replaceFirstChar { it.uppercase() }}(${fieldName}List);
        }
                    """.trimIndent()
                }
                // 嵌套对象的递归处理
                dtoType != originalType && isCustomClass(originalType) -> {
                    """
        if (original.get${fieldName.replaceFirstChar { it.uppercase() }}() != null) {
            dto.set${fieldName.replaceFirstChar { it.uppercase() }}(${originalType}DictDTO.fromOriginal(original.get${fieldName.replaceFirstChar { it.uppercase() }}()));
        }
                    """.trimIndent()
                }
                // 基本类型直接复制
                else -> {
                    "dto.set${fieldName.replaceFirstChar { it.uppercase() }}(original.get${fieldName.replaceFirstChar { it.uppercase() }}());"
                }
            }
        }
    }
    
    /**
     * 生成反向字段复制逻辑
     */
    private fun generateReverseFieldCopyLogic(allFields: List<LsiField>): String {
        return allFields.joinToString("\n        ") { field ->
            val fieldName = field.name ?: "unknown"
            val originalType = field.typeName ?: "Object"
            val dtoType = convertToDtoType(field)
            
            when {
                // 集合类型的反向处理
                field.isCollectionType && dtoType != originalType -> {
                    val elementType = originalType.substringAfter("<").substringBefore(">")
                    """
        if (this.get${fieldName.replaceFirstChar { it.uppercase() }}() != null) {
            List<${elementType}> ${fieldName}List = new ArrayList<>();
            for (${elementType}DictDTO item : this.get${fieldName.replaceFirstChar { it.uppercase() }}()) {
                ${fieldName}List.add(item.toOriginal());
            }
            original.set${fieldName.replaceFirstChar { it.uppercase() }}(${fieldName}List);
        }
                    """.trimIndent()
                }
                // 嵌套对象的反向处理
                dtoType != originalType && isCustomClass(originalType) -> {
                    """
        if (this.get${fieldName.replaceFirstChar { it.uppercase() }}() != null) {
            original.set${fieldName.replaceFirstChar { it.uppercase() }}(this.get${fieldName.replaceFirstChar { it.uppercase() }}().toOriginal());
        }
                    """.trimIndent()
                }
                // 基本类型直接复制
                else -> {
                    "original.set${fieldName.replaceFirstChar { it.uppercase() }}(this.get${fieldName.replaceFirstChar { it.uppercase() }}());"
                }
            }
        }
    }
    
    /**
     * 生成字段注释
     */
    private fun generateFieldComment(field: LsiField): String {
        val fieldName = field.name ?: "unknown"
        val fieldType = field.typeName ?: "Object"
        val dtoType = convertToDtoType(field)
        
        return if (dtoType != fieldType) {
            "$fieldName ($fieldType -> $dtoType)"
        } else {
            "$fieldName ($fieldType)"
        }
    }
    
    /**
     * 生成字典字段注释
     */
    private fun generateDictFieldComment(field: LsiField): String {
        val fieldName = field.name ?: "unknown"
        val dictAnnotation = field.annotations.find { it.simpleName == "Dict" }
        val dicCode = dictAnnotation?.getAttribute("dicCode") as? String
        val tab = dictAnnotation?.getAttribute("tab") as? String
        
        return when {
            !dicCode.isNullOrEmpty() -> "$fieldName (system dict: $dicCode)"
            !tab.isNullOrEmpty() -> "$fieldName (table dict: $tab)"
            else -> "$fieldName (dict field)"
        }
    }
}
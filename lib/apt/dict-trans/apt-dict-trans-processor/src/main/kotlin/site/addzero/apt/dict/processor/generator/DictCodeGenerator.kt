package site.addzero.apt.dict.processor.generator

import com.squareup.javapoet.*
import site.addzero.dict.trans.inter.PrecompiledSql
import site.addzero.dict.trans.inter.DictTranslationFactory
import site.addzero.util.lsi.clazz.LsiClass
import site.addzero.util.lsi.field.LsiField
import java.util.concurrent.CompletableFuture
import javax.lang.model.element.Modifier

/**
 * 字典翻译代码生成器 - 使用 JavaPoet
 * 基于LSI抽象生成字典DSL类
 */
object DictCodeGenerator {

    /**
     * 生成完整的字典DSL Java类 - 使用 JavaPoet
     */
    fun generateDictDslClass(
        packageName: String,
        className: String,
        originalClass: LsiClass,
        dictFields: List<LsiField>,
        systemDicts: Set<String>,
        precompiledSqls: List<PrecompiledSql>
    ): TypeSpec {
        
        val originalClassName = ClassName.get(originalClass.packageName ?: packageName, originalClass.name ?: "Unknown")
        
        return TypeSpec.classBuilder(className)
            .addModifiers(Modifier.PUBLIC)
            .addJavadoc(buildClassJavadoc(originalClass, dictFields))
            .addField(createOriginalField())
            .addMethod(createConstructor(className))
            .addMethod(createTranslateMethod(className))
            .addMethod(createPerformTranslationMethod())
            .addMethods(createSystemDictMethods(systemDicts, dictFields, originalClassName))
            .addMethods(createTableDictMethods(precompiledSqls, dictFields))
            .addMethods(createFieldAccessors(dictFields, originalClassName))
            .addMethods(createUtilityMethods(dictFields, originalClassName))
            .build()
    }
    
    /**
     * 构建类的 JavaDoc
     */
    private fun buildClassJavadoc(originalClass: LsiClass, dictFields: List<LsiField>): CodeBlock {
        val javadoc = CodeBlock.builder()
            .add("Generated dictionary DSL class for \$L\n", originalClass.name)
            .add("Auto-generated by DictTranslateProcessor using LSI-APT\n")
            .add("\n")
            .add("This class provides dictionary translation functionality for:\n")
        
        dictFields.forEach { field ->
            javadoc.add(" * - \$L (\$L)\n", field.name, field.typeName)
        }
        
        return javadoc.build()
    }
    
    /**
     * 创建 original 字段
     */
    private fun createOriginalField(): FieldSpec {
        return FieldSpec.builder(Object::class.java, "original")
            .addModifiers(Modifier.PRIVATE, Modifier.FINAL)
            .build()
    }
    
    /**
     * 创建构造函数
     */
    private fun createConstructor(className: String): MethodSpec {
        return MethodSpec.constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addParameter(Object::class.java, "original")
            .addStatement("this.original = original")
            .build()
    }
    
    /**
     * 创建静态 translate 方法
     */
    private fun createTranslateMethod(className: String): MethodSpec {
        val classType = ClassName.bestGuess(className)
        
        return MethodSpec.methodBuilder("translate")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .addJavadoc("Main translation entry point\n")
            .returns(classType)
            .addParameter(Object::class.java, "original")
            .addStatement("\$T dsl = new \$T(original)", classType, classType)
            .addStatement("dsl.performTranslation()")
            .addStatement("return dsl")
            .build()
    }
    
    /**
     * 创建 performTranslation 方法
     */
    private fun createPerformTranslationMethod(): MethodSpec {
        return MethodSpec.methodBuilder("performTranslation")
            .addModifiers(Modifier.PRIVATE)
            .addJavadoc("Perform concurrent translation of system and table dictionaries\n")
            .returns(TypeName.VOID)
            .addStatement("\$T<\$T> systemDictFuture = \$T.runAsync(this::translateSystemDict)", 
                CompletableFuture::class.java, Void::class.java, CompletableFuture::class.java)
            .addStatement("\$T<\$T> tableDictFuture = \$T.runAsync(this::translateTableDict)", 
                CompletableFuture::class.java, Void::class.java, CompletableFuture::class.java)
            .addStatement("\$T.allOf(systemDictFuture, tableDictFuture).join()", CompletableFuture::class.java)
            .build()
    }

    /**
     * 创建系统字典翻译方法
     */
    private fun createSystemDictMethods(
        systemDicts: Set<String>, 
        dictFields: List<LsiField>, 
        originalClassName: ClassName
    ): List<MethodSpec> {
        
        val systemDictFields = dictFields.filter { field ->
            field.annotations.any { annotation ->
                annotation.hasAttribute("dicCode")
            }
        }
        
        val translateMethod = if (systemDicts.isEmpty()) {
            MethodSpec.methodBuilder("translateSystemDict")
                .addModifiers(Modifier.PRIVATE)
                .addJavadoc("No system dictionaries to translate\n")
                .returns(TypeName.VOID)
                .addComment("No system dicts configured")
                .build()
        } else {
            val methodBuilder = MethodSpec.methodBuilder("translateSystemDict")
                .addModifiers(Modifier.PRIVATE)
                .addJavadoc("Translate system dictionaries: \$L\n", systemDicts.joinToString(", "))
                .returns(TypeName.VOID)
                .beginControlFlow("try")
            
            systemDictFields.forEach { field ->
                val dicCode = field.annotations.find { it.simpleName == "Dict" }
                    ?.getAttribute("dicCode") as? String ?: ""
                val fieldName = field.name ?: "unknown"
                val capitalizedName = fieldName.replaceFirstChar { it.uppercase() }
                
                methodBuilder
                    .addComment("Translate field: $fieldName with dicCode: $dicCode (NO REFLECTION)")
                    .addStatement("Object \$LValue = ((\$T)original).get\$L()", 
                        fieldName, originalClassName, capitalizedName)
                    .beginControlFlow("if (\$LValue != null)", fieldName)
                    .addComment("Use DictTranslationFactory for caching and batch processing")
                    .addStatement("String translatedValue = \$T.translateSystemDict(\$S, \$LValue.toString())", 
                        DictTranslationFactory::class.java, dicCode, fieldName)
                    .beginControlFlow("if (translatedValue != null)")
                    .addStatement("((\$T)original).set\$LName(translatedValue)", 
                        originalClassName, capitalizedName)
                    .endControlFlow()
                    .endControlFlow()
            }
            
            methodBuilder
                .nextControlFlow("catch (Exception e)")
                .addComment("Log error but don't fail the entire translation")
                .addStatement("System.err.println(\"Error in system dict translation: \" + e.getMessage())")
                .endControlFlow()
                .build()
        }
        
        return listOf(translateMethod)
    }

    /**
     * 创建表字典翻译方法
     */
    private fun createTableDictMethods(
        precompiledSqls: List<PrecompiledSql>, 
        dictFields: List<LsiField>
    ): List<MethodSpec> {
        
        val translateMethod = if (precompiledSqls.isEmpty()) {
            MethodSpec.methodBuilder("translateTableDict")
                .addModifiers(Modifier.PRIVATE)
                .addJavadoc("No table dictionaries to translate\n")
                .returns(TypeName.VOID)
                .addComment("No table dicts configured")
                .build()
        } else {
            val methodBuilder = MethodSpec.methodBuilder("translateTableDict")
                .addModifiers(Modifier.PRIVATE)
                .addJavadoc("Translate table dictionaries using precompiled SQL\n")
                .returns(TypeName.VOID)
                .beginControlFlow("try")
            
            precompiledSqls.forEach { sql ->
                val tableResultsVar = "${sql.table}Results"
                methodBuilder
                    .addComment("Execute SQL for table: ${sql.table}")
                    .addStatement("// TODO: Implement table dict translation using DictTranslationFactory")
                    .addComment("Process results and set translated values")
                    .addStatement("// processTableResults(\$S, \$L)", sql.table, tableResultsVar)
            }
            
            methodBuilder
                .nextControlFlow("catch (Exception e)")
                .addComment("Log error but don't fail the entire translation")
                .addStatement("System.err.println(\"Error in table dict translation: \" + e.getMessage())")
                .endControlFlow()
                .build()
        }
        
        return listOf(translateMethod)
    }

    private fun generateFieldAccessors(dictFields: List<LsiField>, originalClass: LsiClass): String {
        return """
    /**
     * Field accessor methods for dictionary fields
     */
    ${
            dictFields.joinToString("\n    \n    ") { field ->
                val fieldName = field.name ?: "unknown"
                val capitalizedName = fieldName.replaceFirstChar { it.uppercase() }
                """
    public Object get$capitalizedName() {
        return ((${originalClass.name})original).get$capitalizedName();
    }
    
    public void set$capitalizedName(Object value) {
        ((${originalClass.name})original).set$capitalizedName(value);
    }
    
    public Object get${capitalizedName}Text() {
        return ((${originalClass.name})original).get${capitalizedName}Name();
    }
    
    public void set${capitalizedName}Text(Object value) {
        ((${originalClass.name})original).set${capitalizedName}Name((String)value);
    }
        """.trimIndent()
            }
        }
        """.trimIndent()
    }

    /**
     * 生成无反射的工具方法
     * 基于编译时生成的表达式，完全避免反射
     */
    private fun generateUtilityMethods(dictFields: List<LsiField>, originalClass: LsiClass): String {
        return """
    /**
     * 获取缓存统计信息
     */
    public Object getCacheStats() {
        return DictTranslationFactory.getCacheStats();
    }
    
    /**
     * 清理所有缓存
     */
    public void clearCaches() {
        DictTranslationFactory.clearCaches();
    }
    
    /**
     * 获取原始对象（用于调试）
     */
    public Object getOriginal() {
        return original;
    }
    
    /**
     * 编译时生成的字段访问方法（无反射）
     */
    ${generateExpressionBasedFieldAccessors(dictFields, originalClass)}
        """.trimIndent()
    }
    
    /**
     * 生成基于表达式的字段访问器（完全无反射）
     */
    private fun generateExpressionBasedFieldAccessors(dictFields: List<LsiField>, originalClass: LsiClass): String {
        return """
    /**
     * 基于编译时表达式的字段值获取（无反射）
     * 所有字段访问都通过编译时生成的getter方法
     */
    ${generateExpressionBasedFieldGetters(dictFields, originalClass)}
    
    /**
     * 基于编译时表达式的字段值设置（无反射）
     * 所有字段设置都通过编译时生成的setter方法
     */
    ${generateExpressionBasedFieldSetters(dictFields, originalClass)}
        """.trimIndent()
    }
    
    /**
     * 生成表达式字段获取器
     */
    private fun generateExpressionBasedFieldGetters(dictFields: List<LsiField>, originalClass: LsiClass): String {
        return dictFields.joinToString("\n    ") { field ->
            val fieldName = field.name ?: "unknown"
            val capitalizedName = fieldName.replaceFirstChar { it.uppercase() }
            """
    private Object getField_$fieldName() {
        return ((${originalClass.name})original).get$capitalizedName();
    }
            """.trimIndent()
        }
    }
    
    /**
     * 生成表达式字段设置器
     */
    private fun generateExpressionBasedFieldSetters(dictFields: List<LsiField>, originalClass: LsiClass): String {
        return dictFields.joinToString("\n    ") { field ->
            val fieldName = field.name ?: "unknown"
            val capitalizedName = fieldName.replaceFirstChar { it.uppercase() }
            """
    private void setField_${fieldName}Name(String value) {
        ((${originalClass.name})original).set${capitalizedName}Name(value);
    }
            """.trimIndent()
        }
    }
}

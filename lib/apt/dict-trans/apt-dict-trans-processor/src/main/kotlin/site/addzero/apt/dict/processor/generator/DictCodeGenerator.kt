package site.addzero.apt.dict.processor.generator

import site.addzero.dict.trans.inter.PrecompiledSql
import site.addzero.util.lsi.clazz.LsiClass
import site.addzero.util.lsi.field.LsiField

/**
 * 字典翻译代码生成器
 * 基于LSI抽象生成字典DSL类
 */
object DictCodeGenerator {

    /**
     * 生成完整的字典DSL Java类
     */
    fun generateDictDslClass(
        packageName: String,
        className: String,
        originalClass: LsiClass,
        dictFields: List<LsiField>,
        systemDicts: Set<String>,
        precompiledSqls: List<PrecompiledSql>
    ): String {
        return """
package $packageName;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.lang.reflect.Field;
import site.addzero.dict.trans.inter.PrecompiledSql;
import site.addzero.dict.trans.inter.TableTranslateContext;
// Note: TransApi and DictModel imports removed as they may not be available at compile time
// The generated code uses Object and Map instead for better compatibility

/**
 * Generated dictionary DSL class for ${originalClass.name}
 * Auto-generated by DictTranslateProcessor using LSI-APT
 * 
 * This class provides dictionary translation functionality for:
${dictFields.joinToString("\n") { " * - ${it.name} (${it.typeName})" }}
 */
public class $className {
    private final Object original;
    
    public $className(Object original) {
        this.original = original;
    }
    
    /**
     * Main translation entry point
     */
    public static $className translate(Object original) {
        $className dsl = new $className(original);
        dsl.performTranslation();
        return dsl;
    }
    
    /**
     * Perform concurrent translation of system and table dictionaries
     */
    private void performTranslation() {
        CompletableFuture<Void> systemDictFuture = CompletableFuture.runAsync(this::translateSystemDict);
        CompletableFuture<Void> tableDictFuture = CompletableFuture.runAsync(this::translateTableDict);
        
        CompletableFuture.allOf(systemDictFuture, tableDictFuture).join();
    }
    
    ${generateSystemDictMethod(systemDicts, dictFields)}
    
    ${generateTableDictMethod(precompiledSqls, dictFields)}
    
    ${generateFieldAccessors(dictFields)}
    
    ${generateUtilityMethods()}
}
        """.trimIndent()
    }

    private fun generateSystemDictMethod(systemDicts: Set<String>, dictFields: List<LsiField>): String {
        if (systemDicts.isEmpty()) {
            return """
    /**
     * No system dictionaries to translate
     */
    private void translateSystemDict() {
        // No system dicts configured
    }
            """.trimIndent()
        }

        val systemDictFields = dictFields.filter { field ->
            val annotations = field.annotations
            val anyHasDictCode = annotations.any { annotation ->
                val hasAttribute = annotation.hasAttribute("dicCode")
                hasAttribute
            }
           anyHasDictCode
        }

        return """
    /**
     * Translate system dictionaries: ${systemDicts.joinToString(", ")}
     */
    private void translateSystemDict() {
        try {
            ${
            systemDictFields.joinToString("\n            ") { field ->
                val dicCode = field.annotations.find { it.simpleName == "Dict" }
                    ?.getAttribute("dicCode") as? String ?: ""
                """
            // Translate field: ${field.name} with dicCode: $dicCode
            Object ${field.name}Value = getFieldValue("${field.name}");
            if (${field.name}Value != null) {
                List<DictModel> ${field.name}Results = transApi.translateDictBatchCode2name("$dicCode", ${field.name}Value.toString());
                if (!${field.name}Results.isEmpty()) {
                    setFieldValue("${field.name}Text", ${field.name}Results.get(0).getName());
                }
            }
                """.trimIndent()
            }
        }
        } catch (Exception e) {
            // Log error but don't fail the entire translation
            System.err.println("Error in system dict translation: " + e.getMessage());
        }
    }
        """.trimIndent()
    }

    private fun generateTableDictMethod(precompiledSqls: List<PrecompiledSql>, dictFields: List<LsiField>): String {
        if (precompiledSqls.isEmpty()) {
            return """
    /**
     * No table dictionaries to translate
     */
    private void translateTableDict() {
        // No table dicts configured
    }
            """.trimIndent()
        }

        return """
    /**
     * Translate table dictionaries using precompiled SQL
     */
    private void translateTableDict() {
        try {
            ${
            precompiledSqls.joinToString("\n            ") { sql ->
                """
            // Execute SQL for table: ${sql.table}
            List<Map<String, Object>> ${sql.table}Results = transApi.executePrecompiledTableSql(
                new PrecompiledSql("${sql.sqlTemplate}", "${sql.table}", "${sql.textColumn}", "${sql.codeColumn}", "${sql.whereCondition}"),
                "" // Keys would be extracted from actual field values
            );
            // Process results and set translated values
            processTableResults("${sql.table}", ${sql.table}Results);
                """.trimIndent()
            }
        }
        } catch (Exception e) {
            // Log error but don't fail the entire translation
            System.err.println("Error in table dict translation: " + e.getMessage());
        }
    }
        """.trimIndent()
    }

    private fun generateFieldAccessors(dictFields: List<LsiField>): String {
        return """
    /**
     * Field accessor methods for dictionary fields
     */
    ${
            dictFields.joinToString("\n    \n    ") { field ->
                val fieldName = field.name ?: "unknown"
                val capitalizedName = fieldName.replaceFirstChar { it.uppercase() }
                """
    public Object get$capitalizedName() {
        return getFieldValue("$fieldName");
    }
    
    public void set$capitalizedName(Object value) {
        setFieldValue("$fieldName", value);
    }
    
    public Object get${capitalizedName}Text() {
        return getFieldValue("${fieldName}Text");
    }
    
    public void set${capitalizedName}Text(Object value) {
        setFieldValue("${fieldName}Text", value);
    }
        """.trimIndent()
            }
        }
        """.trimIndent()
    }

    private fun generateUtilityMethods(): String {
        return """
    /**
     * Utility methods for reflection-based field access
     */
    private Object getFieldValue(String fieldName) {
        try {
            Field field = original.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            return field.get(original);
        } catch (Exception e) {
            return null;
        }
    }
    
    private void setFieldValue(String fieldName, Object value) {
        try {
            Field field = original.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(original, value);
        } catch (Exception e) {
            // Field might not exist (e.g., text fields), ignore silently
        }
    }
    
    private void processTableResults(String tableName, List<Map<String, Object>> results) {
        // Process table translation results
        // Implementation would map results back to object fields
        for (Map<String, Object> result : results) {
            // Map result to appropriate field based on table configuration
        }
    }
    
    public Object getOriginal() {
        return original;
    }
        """.trimIndent()
    }
}

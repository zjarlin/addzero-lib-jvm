package site.addzero.apt.feign

import com.squareup.javapoet.*
import javax.annotation.processing.Filer
import javax.lang.model.element.Modifier

class FeignCodeGenerator(
    private val filer: Filer,
    private val outputPackage: String
) {

    fun generate(meta: ControllerMeta) {
        val feignClientName = meta.className.replace("Controller", "FeignClient")
        val basePath = meta.basePath.takeIf { it.isNotBlank() } ?: "/"

        val interfaceBuilder = TypeSpec.interfaceBuilder(feignClientName)
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(buildFeignClientAnnotation(meta.className, basePath))
            .addJavadoc("Feign Client for ${meta.className}\nGenerated by APT - DO NOT MODIFY\n")

        meta.methods.forEach { methodMeta ->
            interfaceBuilder.addMethod(buildMethodSpec(methodMeta))
        }

        val javaFile = JavaFile.builder(outputPackage, interfaceBuilder.build())
            .addFileComment("Auto-generated by Controller2Feign APT Processor")
            .build()

        javaFile.writeTo(filer)
    }

    private fun buildFeignClientAnnotation(controllerName: String, basePath: String): AnnotationSpec {
        val serviceName = controllerName.replace("Controller", "")
            .replace(Regex("([a-z])([A-Z])"), "$1-$2")
            .lowercase()

        return AnnotationSpec.builder(ClassName.get("org.springframework.cloud.openfeign", "FeignClient"))
            .addMember("name", "\$S", serviceName)
            .addMember("path", "\$S", basePath)
            .build()
    }

    private fun buildMethodSpec(method: MethodMeta): MethodSpec {
        val methodBuilder = MethodSpec.methodBuilder(method.name)
            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
            .addAnnotation(buildHttpMethodAnnotation(method))
            .returns(parseTypeName(method.returnType))

        method.parameters.forEach { param ->
            methodBuilder.addParameter(buildParameterSpec(param))
        }

        return methodBuilder.build()
    }

    private fun buildHttpMethodAnnotation(method: MethodMeta): AnnotationSpec {
        val annotationClass = when (method.httpMethod) {
            HttpMethod.GET -> ClassName.get("org.springframework.web.bind.annotation", "GetMapping")
            HttpMethod.POST -> ClassName.get("org.springframework.web.bind.annotation", "PostMapping")
            HttpMethod.PUT -> ClassName.get("org.springframework.web.bind.annotation", "PutMapping")
            HttpMethod.DELETE -> ClassName.get("org.springframework.web.bind.annotation", "DeleteMapping")
            HttpMethod.PATCH -> ClassName.get("org.springframework.web.bind.annotation", "PatchMapping")
        }

        return AnnotationSpec.builder(annotationClass)
            .addMember("value", "\$S", method.path)
            .build()
    }

    private fun buildParameterSpec(param: ParamMeta): ParameterSpec {
        val paramBuilder = ParameterSpec.builder(parseTypeName(param.type), param.name)

        val annotationClass = when (param.annotation) {
            ParamAnnotation.PATH_VARIABLE -> 
                ClassName.get("org.springframework.web.bind.annotation", "PathVariable")
            ParamAnnotation.REQUEST_PARAM -> 
                ClassName.get("org.springframework.web.bind.annotation", "RequestParam")
            ParamAnnotation.REQUEST_BODY -> 
                ClassName.get("org.springframework.web.bind.annotation", "RequestBody")
            ParamAnnotation.REQUEST_HEADER -> 
                ClassName.get("org.springframework.web.bind.annotation", "RequestHeader")
            ParamAnnotation.NONE -> null
        }

        annotationClass?.let {
            val annoBuilder = AnnotationSpec.builder(it)
            if (param.annotation != ParamAnnotation.REQUEST_BODY) {
                annoBuilder.addMember("value", "\$S", param.name)
            }
            paramBuilder.addAnnotation(annoBuilder.build())
        }

        return paramBuilder.build()
    }

    private fun parseTypeName(typeString: String): TypeName {
        return when {
            typeString == "void" -> TypeName.VOID
            typeString == "int" -> TypeName.INT
            typeString == "long" -> TypeName.LONG
            typeString == "boolean" -> TypeName.BOOLEAN
            typeString == "double" -> TypeName.DOUBLE
            typeString == "float" -> TypeName.FLOAT
            typeString.contains("<") -> parseGenericType(typeString)
            typeString.contains(".") -> ClassName.bestGuess(typeString)
            else -> ClassName.get("java.lang", typeString.replaceFirstChar { it.uppercase() })
        }
    }

    private fun parseGenericType(typeString: String): TypeName {
        val rawType = typeString.substringBefore("<")
        val typeArgs = typeString.substringAfter("<").substringBeforeLast(">")
            .split(",")
            .map { it.trim() }
            .filter { it.isNotBlank() }
            .map { parseTypeName(it) }
            .toTypedArray()

        val rawClassName = ClassName.bestGuess(rawType)
        return if (typeArgs.isNotEmpty()) {
            ParameterizedTypeName.get(rawClassName, *typeArgs)
        } else {
            rawClassName
        }
    }
}

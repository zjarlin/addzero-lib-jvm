# 差量 DDL 生成使用指南

## 概述

差量 DDL 生成系统可以比对代码中的实体定义与数据库中的实际表结构，自动生成需要执行的 DDL 语句。

## 功能特性

### 支持的差量比对类型

1. **表差量** (`diffTable`)
   - 检测代码中有但数据库中没有的表
   - 生成 `CREATE TABLE` 语句

2. **列差量** (`diffColumn`)
   - 检测表中缺失的列
   - 生成 `ALTER TABLE ADD COLUMN` 语句

3. **唯一索引差量** (`diffUniqueIndexes`)
   - 检测缺失的唯一索引和联合索引
   - 生成 `CREATE UNIQUE INDEX` 语句
   - 支持 Jimmer 的 `@Key` 和 `@Unique` 注解

4. **外键差量** (`diffForeignKeys`)
   - 检测缺失的外键约束
   - 生成 `ALTER TABLE ADD CONSTRAINT` 语句

5. **外键删除** (`diffDropForeignKeys`)
   - 检测多余的外键（当 `autoddlAllowDeleteColumn=true` 时）
   - 生成 `ALTER TABLE DROP CONSTRAINT` 语句

## 配置项

在 `application.yml` 或注解处理器参数中配置：

```yaml
jimmer:
  autoddl:
    jdbc-url: jdbc:postgresql://localhost:5432/mydb
    jdbc-username: postgres
    jdbc-password: password
    foreign-keys: true              # 是否生成外键
    keys: true                       # 是否生成索引
    allow-delete-column: false       # 是否允许删除操作
    exclude-tables:                  # 排除的表（支持通配符）
      - flyway_schema_history
      - "*_mapping"
```

## 使用方式

### 方式一：使用扩展函数

```kotlin
import site.addzero.util.ddlgenerator.extension.*
import site.addzero.util.lsi.clazz.LsiClass

// 获取所有实体类
val lsiClasses: List<LsiClass> = scanEntities()

// 生成差量 DDL
val diffResult = lsiClasses.generateDiffDdl()

// 打印统计信息
diffResult.printSummary()

// 输出 SQL
val sql = diffResult.toSql()
File("diff.sql").writeText(sql)

// 或者直接生成 SQL 字符串
val sqlDirect = lsiClasses.toDiffDDL()
```

### 方式二：使用主逻辑函数

```kotlin
import site.addzero.util.ddlgenerator.extension.mainLogic

val sql = mainLogic(lsiClasses)
println(sql)
```

### 方式三：分步执行

```kotlin
import site.addzero.util.ddlgenerator.diff.comparator.*

// 1. 检查需要创建的表
val newTables = lsiClasses.diffTable()
println("需要创建 ${newTables.size} 个表")

// 2. 检查需要添加的列
val newColumns = lsiClasses.diffColumn()
println("需要添加 ${newColumns.size} 个列")

// 3. 检查需要添加的索引
val newIndexes = lsiClasses.diffUniqueIndexes()
println("需要添加 ${newIndexes.size} 个索引")

// 4. 检查需要添加的外键
val newForeignKeys = lsiClasses.diffForeignKeys()
println("需要添加 ${newForeignKeys.size} 个外键")

// 5. 检查需要删除的外键（可选）
val obsoleteForeignKeys = lsiClasses.diffDropForeignKeys()
println("需要删除 ${obsoleteForeignKeys.size} 个外键")
```

## 输出示例

### 统计信息输出

```
============================================================
Diff DDL Summary
============================================================
Tables to create:      2
Columns to add:        5
Indexes to add:        3
Foreign keys to add:   4
Foreign keys to drop:  0
Total statements:      14
============================================================
```

### SQL 输出示例

```sql
-- =============================================
-- Phase 1: Create Missing Tables
-- =============================================
CREATE TABLE "user" (
  "id" BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  "username" VARCHAR(50) NOT NULL,
  "email" VARCHAR(100) NOT NULL,
  "created_at" TIMESTAMP NOT NULL
);

CREATE TABLE "role" (
  "id" BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  "name" VARCHAR(50) NOT NULL
);

-- =============================================
-- Phase 2: Add Missing Columns
-- =============================================
ALTER TABLE "user" ADD COLUMN "phone" VARCHAR(20);
ALTER TABLE "user" ADD COLUMN "address" TEXT;

-- =============================================
-- Phase 4: Add Missing Indexes
-- =============================================
CREATE UNIQUE INDEX "uk_user_username" ON "user" ("username");
CREATE UNIQUE INDEX "uk_user_email" ON "user" ("email");
CREATE UNIQUE INDEX "uk_role_name" ON "role" ("name");

-- =============================================
-- Phase 5: Add Missing Foreign Keys
-- =============================================
ALTER TABLE "user_role" ADD CONSTRAINT "fk_user_role_user"
  FOREIGN KEY ("user_id") REFERENCES "user" ("id");
ALTER TABLE "user_role" ADD CONSTRAINT "fk_user_role_role"
  FOREIGN KEY ("role_id") REFERENCES "role" ("id");
```

## DDL 生成顺序

系统按以下顺序生成 DDL 语句，确保执行时不会出现依赖问题：

1. **Phase 1**: 创建缺失的表
2. **Phase 2**: 添加缺失的列
3. **Phase 3**: 删除多余的外键（如果允许）
4. **Phase 4**: 添加缺失的索引
5. **Phase 5**: 添加缺失的外键

## 索引比对规则

系统支持以下索引类型的比对：

### 1. 单列唯一索引

```kotlin
@Key  // Jimmer 唯一键
var username: String

@Unique  // JPA 唯一约束
var email: String
```

生成：
```sql
CREATE UNIQUE INDEX "uk_user_username" ON "user" ("username");
CREATE UNIQUE INDEX "uk_user_email" ON "user" ("email");
```

### 2. 联合唯一索引

```kotlin
@Key(group = "user_profile")
var userId: Long

@Key(group = "user_profile")
var profileType: String
```

生成：
```sql
CREATE UNIQUE INDEX "uk_user_user_profile" ON "user" ("userId", "profileType");
```

## 外键比对规则

系统会比对外键的：
- 列名 (`columnName`)
- 引用表名 (`referencedTableName`)
- 引用列名 (`referencedColumnName`)

只有当这三个属性完全匹配时才认为是同一个外键。

## 注意事项

1. **表名匹配**：比对时使用实体类的 `name` 属性与数据库表名匹配
2. **列名匹配**：优先使用 `columnName`，如果没有则使用字段的 `name`
3. **排除表**：通过 `autoddlExcludeTables` 配置可以排除某些表（支持通配符 `*`）
4. **索引匹配**：比对索引名或列组合 + 索引类型
5. **安全性**：默认不删除外键，需要显式配置 `allow-delete-column=true`

## 扩展开发

### 添加自定义差量比对

```kotlin
// 在 LsiJdbcMetadataDiff.kt 中添加新的扩展函数
fun List<LsiClass>.diffCustomFeature(): List<String> {
    val metadata = getJdbcMetadata()
    // 实现自定义比对逻辑
    return emptyList()
}

// 在 MainLogic.kt 中集成
fun List<LsiClass>.generateDiffDdl(): DiffDdlResult {
    // ...
    val customFeatures = diffCustomFeature()
    // ...
}
```

### 添加数据库方言支持

在 `DatabaseMetadataReaderExt.kt` 中添加特定数据库的元数据读取逻辑。

## 相关文件

- `LsiJdbcMetadataDiff.kt` - 差量比对核心逻辑
- `MainLogic.kt` - 主流程组织
- `DatabaseMetadataReaderExt.kt` - 数据库元数据读取扩展
- `DdlGenerationStrategy` 接口 - DDL 生成策略（支持多数据库方言）
